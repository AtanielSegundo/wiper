use crate::fs::{path_to_folder, DataStore, DataStoreKey, Folder, FolderEntryType};
use crate::logger::{Logger, MessageLevel};
use std::collections::VecDeque;
use std::marker::PhantomData;
use std::path::PathBuf;
use std::sync::mpsc::{self, Receiver, Sender};
use std::sync::{Arc, Mutex};
use std::thread;

#[derive(Debug)]
pub struct TaskManager<S: DataStore<DataStoreKey>> {
    task_queue: Arc<Mutex<VecDeque<PathBuf>>>,
    result_sender: Sender<(PathBuf, Folder)>,
    result_receiver: Receiver<(PathBuf, Folder)>,
    worker_handle: Option<thread::JoinHandle<()>>,
    _store: PhantomData<S>,
}

impl<S: DataStore<DataStoreKey>> TaskManager<S> {
    pub fn new() -> Self {
        let (result_sender, result_receiver) = mpsc::channel();
        let task_queue = Arc::new(Mutex::new(VecDeque::new()));

        let worker_queue = Arc::clone(&task_queue);
        let worker_sender = result_sender.clone();

        // Spawn a single worker thread
        let worker_handle = thread::spawn(move || {
            loop {
                let task = {
                    let mut queue = worker_queue.lock().unwrap();
                    if queue.is_empty() {
                        // If the queue is empty, we might sleep or periodically check for tasks
                        thread::sleep(std::time::Duration::from_millis(100));
                        continue;
                    }
                    queue.pop_front()
                };

                if let Some(path_buf) = task {
                    // Process the task
                    let folder = path_to_folder(path_buf.clone()); // Assume this function exists
                    worker_sender.send((path_buf, folder)).unwrap();
                }
            }
        });

        TaskManager {
            task_queue,
            result_sender,
            result_receiver,
            worker_handle: Some(worker_handle),
            _store: PhantomData,
        }
    }

    pub fn add_task(&self, path_buf: PathBuf) {
        let mut queue = self.task_queue.lock().unwrap();
        queue.push_back(path_buf);
    }

    pub fn handle_results(&self) {
        // Handle incoming results from the worker thread
        for (path_buf, folder) in self.result_receiver.try_iter() {
            // Process results here
            println!("Processed: {:?}, Result: {:?}", path_buf, folder);
        }
    }

    // Gracefully shutdown the worker thread when the TaskManager is dropped
    pub fn stop_worker(&mut self) {
        if let Some(handle) = self.worker_handle.take() {
            // Send a termination signal to the thread if needed
            // For now, we just join the thread
            handle.join().unwrap();
        }
    }
}
